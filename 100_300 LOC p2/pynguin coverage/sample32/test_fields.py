# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import fields as module_0
import uuid as module_1
import re as module_2
import enum as module_3
import decimal as module_4


def test_case_0():
    number_0 = module_0.Number()
    assert (
        f"{type(number_0).__module__}.{type(number_0).__qualname__}" == "fields.Number"
    )
    assert number_0.title == ""
    assert number_0.description == ""
    assert number_0.allow_null is False
    assert number_0.minimum is None
    assert number_0.maximum is None
    assert number_0.exclusive_minimum is None
    assert number_0.exclusive_maximum is None
    assert number_0.multiple_of is None
    assert number_0.precision is None
    assert module_0.Number.errors == {
        "type": "Must be a number.",
        "null": "May not be null.",
        "integer": "Must be an integer.",
        "finite": "Must be finite.",
        "minimum": "Must be greater than or equal to {minimum}.",
        "exclusive_minimum": "Must be greater than {exclusive_minimum}.",
        "maximum": "Must be less than or equal to {maximum}.",
        "exclusive_maximum": "Must be less than {exclusive_maximum}.",
        "multiple_of": "Must be a multiple of {multiple_of}.",
    }


def test_case_1():
    time_0 = module_0.Time()
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None
    validation_result_0 = time_0.validate_or_error(time_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_2():
    float_0 = module_0.Float()
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is None
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is None
    assert float_0.multiple_of is None
    assert float_0.precision is None
    union_0 = float_0.__or__(float_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }


def test_case_3():
    date_0 = module_0.Date()
    assert f"{type(date_0).__module__}.{type(date_0).__qualname__}" == "fields.Date"
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None


def test_case_4():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }


@pytest.mark.xfail(strict=True)
def test_case_5():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    str_0 = "U"
    validation_result_0 = date_time_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    date_time_0.serialize(validation_result_0)


def test_case_6():
    float_0 = 4726.0
    float_1 = module_0.Float(
        minimum=float_0, maximum=float_0, exclusive_maximum=float_0
    )
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.maximum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.multiple_of is None
    assert float_1.precision is None
    validation_result_0 = float_1.validate_or_error(float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_7():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    validation_result_0 = integer_0.validate_or_error(integer_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_8():
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }


def test_case_9():
    str_0 = "-jc"
    choice_0 = module_0.Choice(choices=str_0)
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == [("-", "-"), ("j", "j"), ("c", "c")]
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }


def test_case_10():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }


@pytest.mark.xfail(strict=True)
def test_case_11():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "tf)as^FPBqK<8C"
    dict_0 = {str_0: object_0, str_0: object_0, str_0: object_0, str_0: object_0}
    object_1 = module_0.Object(pattern_properties=dict_0, property_names=object_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert (
        f"{type(object_1.pattern_properties).__module__}.{type(object_1.pattern_properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.pattern_properties) == 1
    assert object_1.additional_properties is True
    assert (
        f"{type(object_1.property_names).__module__}.{type(object_1.property_names).__qualname__}"
        == "fields.Object"
    )
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert object_1.required == []
    object_1.validate_or_error(dict_0)


def test_case_12():
    array_0 = module_0.Array()
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }


def test_case_13():
    none_type_0 = None
    const_0 = module_0.Const(none_type_0)
    assert f"{type(const_0).__module__}.{type(const_0).__qualname__}" == "fields.Const"
    assert const_0.title == ""
    assert const_0.description == ""
    assert const_0.allow_null is False
    assert const_0.const is None
    assert module_0.Const.errors == {
        "only_null": "Must be null.",
        "const": "Must be the value '{const}'.",
    }


def test_case_14():
    none_type_0 = None
    any_0 = module_0.Any(default=none_type_0)
    assert any_0.default is None
    assert any_0.title == ""
    assert any_0.description == ""
    float_0 = module_0.Float(exclusive_maximum=none_type_0, precision=none_type_0)
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is None
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is None
    assert float_0.multiple_of is None
    assert float_0.precision is None
    validation_result_0 = float_0.serialize(float_0)
    assert validation_result_0.title == ""
    assert validation_result_0.description == ""
    assert validation_result_0.allow_null is False


def test_case_15():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    string_0 = module_0.String(allow_blank=object_0)
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert (
        f"{type(string_0.allow_blank).__module__}.{type(string_0.allow_blank).__qualname__}"
        == "fields.Object"
    )
    assert string_0.trim_whitespace is True
    assert string_0.max_length is None
    assert string_0.min_length is None
    assert string_0.format is None
    assert string_0.pattern is None
    assert string_0.pattern_regex is None
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }


def test_case_16():
    text_0 = module_0.Text()
    assert f"{type(text_0).__module__}.{type(text_0).__qualname__}" == "fields.Text"
    assert text_0.title == ""
    assert text_0.description == ""
    assert text_0.allow_null is False
    assert text_0.allow_blank is False
    assert text_0.trim_whitespace is True
    assert text_0.max_length is None
    assert text_0.min_length is None
    assert text_0.format == "text"
    assert text_0.pattern is None
    assert text_0.pattern_regex is None


def test_case_17():
    time_0 = module_0.Time()
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None


def test_case_18():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None


@pytest.mark.xfail(strict=True)
def test_case_19():
    none_type_0 = None
    object_0 = module_0.Object(
        min_properties=none_type_0, max_properties=none_type_0, required=none_type_0
    )
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    date_0 = module_0.Date()
    assert f"{type(date_0).__module__}.{type(date_0).__qualname__}" == "fields.Date"
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None
    validation_result_0 = object_0.validate_or_error(none_type_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    module_0.Boolean(description=none_type_0)


def test_case_20():
    complex_0 = -197 - 845.6j
    with pytest.raises(AssertionError):
        module_0.String(max_length=complex_0)


def test_case_21():
    str_0 = "(\x0bM,\x0c22E"
    with pytest.raises(AssertionError):
        module_0.Number(minimum=str_0)


def test_case_22():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    array_0 = module_0.Array(integer_0, integer_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert (
        f"{type(array_0.items).__module__}.{type(array_0.items).__qualname__}"
        == "fields.Integer"
    )
    assert (
        f"{type(array_0.additional_items).__module__}.{type(array_0.additional_items).__qualname__}"
        == "fields.Integer"
    )
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }


def test_case_23():
    float_0 = 4726.0
    boolean_0 = module_0.Boolean(allow_null=float_0)
    assert boolean_0.default is None
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = boolean_0.validate_or_error(object_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_24():
    none_type_0 = None
    any_0 = module_0.Any(default=none_type_0)
    assert any_0.default is None
    assert any_0.title == ""
    assert any_0.description == ""


def test_case_25():
    var_0 = module_1.getnode()
    float_0 = module_0.Float(exclusive_minimum=var_0, exclusive_maximum=var_0)
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is None
    assert float_0.exclusive_minimum == 32989410669706
    assert float_0.exclusive_maximum == 32989410669706
    assert float_0.multiple_of is None
    assert float_0.precision is None


def test_case_26():
    complex_0 = -128.3213 - 2702.88j
    bool_0 = False
    with pytest.raises(AssertionError):
        module_0.Array(additional_items=complex_0, max_items=bool_0)


def test_case_27():
    string_0 = module_0.String()
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.allow_blank is False
    assert string_0.trim_whitespace is True
    assert string_0.max_length is None
    assert string_0.min_length is None
    assert string_0.format is None
    assert string_0.pattern is None
    assert string_0.pattern_regex is None
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }


@pytest.mark.xfail(strict=True)
def test_case_28():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    str_0 = "3"
    validation_result_0 = date_time_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    float_0 = -434.6547
    module_0.Float(
        exclusive_minimum=validation_result_0,
        exclusive_maximum=validation_result_0,
        multiple_of=float_0,
    )


@pytest.mark.xfail(strict=True)
def test_case_29():
    none_type_0 = None
    float_0 = module_0.Float(exclusive_maximum=none_type_0, precision=none_type_0)
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is None
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is None
    assert float_0.multiple_of is None
    assert float_0.precision is None
    float_0.validate(float_0)


def test_case_30():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    union_0 = integer_0.__or__(integer_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    validation_result_0 = union_0.validate_or_error(integer_0, strict=integer_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_31():
    float_0 = 4737.811536529645
    number_0 = module_0.Number(maximum=float_0, exclusive_maximum=float_0)
    assert (
        f"{type(number_0).__module__}.{type(number_0).__qualname__}" == "fields.Number"
    )
    assert number_0.title == ""
    assert number_0.description == ""
    assert number_0.allow_null is False
    assert number_0.minimum is None
    assert number_0.maximum == pytest.approx(4737.811536529645, abs=0.01, rel=0.01)
    assert number_0.exclusive_minimum is None
    assert number_0.exclusive_maximum == pytest.approx(
        4737.811536529645, abs=0.01, rel=0.01
    )
    assert number_0.multiple_of is None
    assert number_0.precision is None
    assert module_0.Number.errors == {
        "type": "Must be a number.",
        "null": "May not be null.",
        "integer": "Must be an integer.",
        "finite": "Must be finite.",
        "minimum": "Must be greater than or equal to {minimum}.",
        "exclusive_minimum": "Must be greater than {exclusive_minimum}.",
        "maximum": "Must be less than or equal to {maximum}.",
        "exclusive_maximum": "Must be less than {exclusive_maximum}.",
        "multiple_of": "Must be a multiple of {multiple_of}.",
    }
    validation_result_0 = number_0.validate_or_error(float_0, strict=float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_32():
    var_0 = module_2.purge()
    float_0 = module_0.Float(exclusive_minimum=var_0, exclusive_maximum=var_0)
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is None
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is None
    assert float_0.multiple_of is None
    assert float_0.precision is None
    validation_result_0 = float_0.validate_or_error(var_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_33():
    boolean_0 = module_0.Boolean()
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    validation_result_0 = boolean_0.validate_or_error(boolean_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_34():
    bool_0 = False
    array_0 = module_0.Array(additional_items=bool_0, max_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is False
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }


def test_case_35():
    complex_0 = -197 - 845.6j
    bool_0 = False
    with pytest.raises(AssertionError):
        module_0.Array(max_items=complex_0, exact_items=bool_0)


def test_case_36():
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    var_0 = choice_0.get_default_value()


def test_case_37():
    none_type_0 = None
    string_0 = module_0.String(
        allow_blank=none_type_0, max_length=none_type_0, format=none_type_0
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.allow_blank is None
    assert string_0.trim_whitespace is True
    assert string_0.max_length is None
    assert string_0.min_length is None
    assert string_0.format is None
    assert string_0.pattern is None
    assert string_0.pattern_regex is None
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    validation_result_0 = string_0.validate_or_error(none_type_0, strict=string_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_38():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    var_0 = string_0.serialize(str_0)
    assert var_0 == "-c"


def test_case_39():
    bool_0 = True
    with pytest.raises(AssertionError):
        module_0.Array(bool_0, unique_items=bool_0)


def test_case_40():
    array_0 = module_0.Array()
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    var_0 = array_0.serialize(array_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "fields.Array"
    assert var_0.title == ""
    assert var_0.description == ""
    assert var_0.allow_null is False
    assert var_0.items is None
    assert var_0.additional_items is False
    assert var_0.min_items is None
    assert var_0.max_items is None
    assert var_0.unique_items is False


def test_case_41():
    any_0 = module_0.Any()
    assert any_0.title == ""
    assert any_0.description == ""
    float_0 = any_0.get_default_value()
    validation_result_0 = any_0.validate(float_0)


def test_case_42():
    bool_0 = False
    array_0 = module_0.Array(max_items=bool_0, exact_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is False
    assert array_0.max_items is False
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }


@pytest.mark.xfail(strict=True)
def test_case_43():
    none_type_0 = None
    any_0 = module_0.Any(default=none_type_0)
    assert any_0.default is None
    assert any_0.title == ""
    assert any_0.description == ""
    bool_0 = True
    boolean_0 = module_0.Boolean(allow_null=bool_0)
    assert boolean_0.default is None
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    var_0 = boolean_0.validate(none_type_0)
    module_0.Decimal(maximum=boolean_0, exclusive_maximum=var_0)


@pytest.mark.xfail(strict=True)
def test_case_44():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    array_0 = module_0.Array(string_0, exact_items=string_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert (
        f"{type(array_0.items).__module__}.{type(array_0.items).__qualname__}"
        == "fields.String"
    )
    assert array_0.additional_items is False
    assert (
        f"{type(array_0.min_items).__module__}.{type(array_0.min_items).__qualname__}"
        == "fields.String"
    )
    assert (
        f"{type(array_0.max_items).__module__}.{type(array_0.max_items).__qualname__}"
        == "fields.String"
    )
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    array_0.serialize(string_0)


@pytest.mark.xfail(strict=True)
def test_case_45():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    choice_0.validate(date_time_0)


@pytest.mark.xfail(strict=True)
def test_case_46():
    array_0 = module_0.Array()
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    var_0 = array_0.serialize(array_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "fields.Array"
    assert var_0.title == ""
    assert var_0.description == ""
    assert var_0.allow_null is False
    assert var_0.items is None
    assert var_0.additional_items is False
    assert var_0.min_items is None
    assert var_0.max_items is None
    assert var_0.unique_items is False
    validation_result_0 = array_0.validate_or_error(var_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    str_0 = ")B[29L>s3u"
    module_0.Any(title=array_0, description=str_0, allow_null=var_0)


def test_case_47():
    none_type_0 = None
    str_0 = "="
    bool_0 = True
    object_0 = module_0.Object(property_names=none_type_0, min_properties=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    boolean_0 = module_0.Boolean(default=bool_0, allow_null=object_0)
    assert boolean_0.default is True
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    validation_result_0 = boolean_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_48():
    bool_0 = False
    any_0 = module_0.Any(allow_null=bool_0)
    assert any_0.title == ""
    assert any_0.description == ""
    dict_0 = {}
    float_0 = module_0.Float(
        maximum=bool_0, exclusive_maximum=bool_0, multiple_of=bool_0, **dict_0
    )
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is False
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is False
    assert float_0.multiple_of is False
    assert float_0.precision is None
    var_0 = any_0.validate(any_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "fields.Any"
    assert var_0.title == ""
    assert var_0.description == ""
    assert var_0.allow_null is False
    var_1 = var_0.validate(bool_0)
    validation_result_0 = float_0.validate_or_error(var_1)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_49():
    float_0 = 4726.0
    float_1 = module_0.Float(
        maximum=float_0,
        exclusive_minimum=float_0,
        precision=float_0,
        multiple_of=float_0,
    )
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum is None
    assert float_1.maximum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.exclusive_minimum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.precision == pytest.approx(4726.0, abs=0.01, rel=0.01)
    validation_result_0 = float_1.validate_or_error(float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_50():
    none_type_0 = None
    with pytest.raises(AssertionError):
        module_0.Array(none_type_0, exact_items=none_type_0, unique_items=none_type_0)


def test_case_51():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = ""
    validation_result_0 = integer_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_52():
    float_0 = 2574.897442
    float_1 = module_0.Float(minimum=float_0)
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum == pytest.approx(2574.897442, abs=0.01, rel=0.01)
    assert float_1.maximum is None
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of is None
    assert float_1.precision is None
    validation_result_0 = float_1.validate_or_error(float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == pytest.approx(2574.897442, abs=0.01, rel=0.01)
    assert validation_result_0.error is None


@pytest.mark.xfail(strict=True)
def test_case_53():
    none_type_0 = None
    any_0 = module_0.Any(allow_null=none_type_0)
    assert any_0.title == ""
    assert any_0.description == ""
    module_0.Float(multiple_of=any_0)


def test_case_54():
    var_0 = module_1.uuid4()
    dict_0 = {var_0: var_0}
    with pytest.raises(AssertionError):
        module_0.Object(properties=dict_0, property_names=var_0)


@pytest.mark.xfail(strict=True)
def test_case_55():
    regex_flag_0 = module_2.RegexFlag.VERBOSE
    integer_0 = module_0.Integer(minimum=regex_flag_0, multiple_of=regex_flag_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == module_2.RegexFlag.VERBOSE
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of == module_2.RegexFlag.VERBOSE
    assert integer_0.precision is None
    validation_result_0 = integer_0.validate_or_error(regex_flag_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == 64
    assert validation_result_0.error is None
    module_0.Object(
        property_names=integer_0, max_properties=regex_flag_0, required=regex_flag_0
    )


def test_case_56():
    str_0 = "-c"
    int_0 = 3411
    const_0 = module_0.Const(int_0)
    assert f"{type(const_0).__module__}.{type(const_0).__qualname__}" == "fields.Const"
    assert const_0.title == ""
    assert const_0.description == ""
    assert const_0.allow_null is False
    assert const_0.const == 3411
    assert module_0.Const.errors == {
        "only_null": "Must be null.",
        "const": "Must be the value '{const}'.",
    }
    var_0 = const_0.validate(int_0)
    assert var_0 == 3411
    validation_result_0 = const_0.validate_or_error(int_0, strict=str_0)


def test_case_57():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = ""
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = integer_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    with pytest.raises(AssertionError):
        module_0.String(pattern=validation_result_0)


def test_case_58():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    object_0 = module_0.Object(additional_properties=integer_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert (
        f"{type(object_0.additional_properties).__module__}.{type(object_0.additional_properties).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = integer_0.validate_or_error(integer_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_59():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    none_type_0 = None
    with pytest.raises(AssertionError):
        module_0.Object(
            pattern_properties=none_type_0,
            additional_properties=str_0,
            min_properties=none_type_0,
            max_properties=bool_0,
        )


@pytest.mark.xfail(strict=True)
def test_case_60():
    boolean_0 = module_0.Boolean()
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    validation_result_0 = boolean_0.get_default_value()
    boolean_0.validate(validation_result_0)


def test_case_61():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    validation_result_0 = string_0.validate_or_error(string_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_62():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    str_0 = "content"
    validation_result_0 = date_time_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_63():
    float_0 = 4726.0
    integer_0 = module_0.Integer(minimum=float_0, multiple_of=float_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert integer_0.precision is None
    validation_result_0 = integer_0.validate_or_error(float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == 4726
    assert validation_result_0.error is None


def test_case_64():
    bool_0 = False
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.allow_blank is False
    assert string_0.trim_whitespace is False
    assert string_0.max_length is False
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    validation_result_0 = string_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_65():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    validation_result_0 = string_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_66():
    bool_0 = True
    str_0 = " "
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == " "
    assert string_0.pattern == " "
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    validation_result_0 = string_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_67():
    none_type_0 = None
    decimal_0 = module_0.Decimal(maximum=none_type_0)
    assert (
        f"{type(decimal_0).__module__}.{type(decimal_0).__qualname__}"
        == "fields.Decimal"
    )
    assert decimal_0.title == ""
    assert decimal_0.description == ""
    assert decimal_0.allow_null is False
    assert decimal_0.minimum is None
    assert decimal_0.maximum is None
    assert decimal_0.exclusive_minimum is None
    assert decimal_0.exclusive_maximum is None
    assert decimal_0.multiple_of is None
    assert decimal_0.precision is None
    var_0 = module_1.getnode()
    decimal_0.serialize(decimal_0)


def test_case_68():
    time_0 = module_0.Time()
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None
    union_0 = time_0.__or__(time_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    validation_result_0 = union_0.validate_or_error(union_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_69():
    float_0 = 4726.0
    with pytest.raises(AssertionError):
        module_0.Object(max_properties=float_0)


def test_case_70():
    none_type_0 = None
    object_0 = module_0.Object(
        properties=none_type_0,
        pattern_properties=none_type_0,
        min_properties=none_type_0,
        max_properties=none_type_0,
    )
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    bool_0 = False
    with pytest.raises(AssertionError):
        module_0.String(allow_blank=bool_0, max_length=none_type_0, min_length=object_0)


def test_case_71():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    validation_result_0 = integer_0.validate_or_error(integer_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    object_0 = module_0.Object(additional_properties=integer_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert (
        f"{type(object_0.additional_properties).__module__}.{type(object_0.additional_properties).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_1 = object_0.validate_or_error(enum_dict_0, strict=object_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value == {}
    assert validation_result_1.error is None
    bool_0 = False
    var_0 = module_1.uuid1()
    with pytest.raises(AssertionError):
        module_0.String(allow_blank=bool_0, format=var_0)


def test_case_72():
    bool_0 = True
    string_0 = module_0.String(max_length=bool_0, min_length=bool_0)
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.allow_blank is False
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is True
    assert string_0.format is None
    assert string_0.pattern is None
    assert string_0.pattern_regex is None
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    date_0 = module_0.Date()
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None
    none_type_0 = None
    string_1 = module_0.String(allow_blank=bool_0, pattern=none_type_0)
    assert string_1.title == ""
    assert string_1.description == ""
    assert string_1.allow_null is False
    assert string_1.default == ""
    validation_result_0 = string_1.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == ""
    assert validation_result_0.error is None


def test_case_73():
    none_type_0 = None
    float_0 = module_0.Float(
        minimum=none_type_0, maximum=none_type_0, exclusive_maximum=none_type_0
    )
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum is None
    assert float_0.maximum is None
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is None
    assert float_0.multiple_of is None
    assert float_0.precision is None
    union_0 = float_0.__or__(float_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    validation_result_0 = union_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_74():
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    with pytest.raises(AssertionError):
        module_0.Object(property_names=choice_0, min_properties=choice_0)


def test_case_75():
    none_type_0 = None
    array_0 = module_0.Array(none_type_0, exact_items=none_type_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    validation_result_0 = array_0.validate_or_error(none_type_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_76():
    float_0 = 4726.0
    bool_0 = False
    object_0 = module_0.Object(min_properties=bool_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is False
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    float_1 = module_0.Float(minimum=float_0, precision=float_0)
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.maximum is None
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of is None
    assert float_1.precision == pytest.approx(4726.0, abs=0.01, rel=0.01)
    var_0 = float_1.validate(float_0)
    assert var_0 == pytest.approx(4726.0, abs=0.01, rel=0.01)
    bool_1 = True
    field_0 = module_0.Field()
    assert field_0.title == ""
    assert field_0.description == ""
    validation_result_0 = object_0.validate_or_error(var_0, strict=bool_1)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    const_0 = module_0.Const(validation_result_0)
    assert f"{type(const_0).__module__}.{type(const_0).__qualname__}" == "fields.Const"
    assert const_0.title == ""
    assert const_0.description == ""
    assert const_0.allow_null is False
    assert (
        f"{type(const_0.const).__module__}.{type(const_0.const).__qualname__}"
        == "base.ValidationResult"
    )
    assert module_0.Const.errors == {
        "only_null": "Must be null.",
        "const": "Must be the value '{const}'.",
    }
    field_0.validate_or_error(var_0)


def test_case_77():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    none_type_0 = None
    validation_result_0 = choice_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_78():
    float_0 = -1115.608
    float_1 = module_0.Float(minimum=float_0, precision=float_0)
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum == pytest.approx(-1115.608, abs=0.01, rel=0.01)
    assert float_1.maximum is None
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of is None
    assert float_1.precision == pytest.approx(-1115.608, abs=0.01, rel=0.01)
    float_1.validate_or_error(float_0, strict=float_1)


@pytest.mark.xfail(strict=True)
def test_case_79():
    float_0 = 4767.202588446283
    integer_0 = module_0.Integer(minimum=float_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == pytest.approx(4767.202588446283, abs=0.01, rel=0.01)
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    none_type_0 = None
    validation_result_0 = integer_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    integer_0.validate(float_0)


@pytest.mark.xfail(strict=True)
def test_case_80():
    boolean_0 = module_0.Boolean()
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    number_0 = module_0.Number()
    assert (
        f"{type(number_0).__module__}.{type(number_0).__qualname__}" == "fields.Number"
    )
    assert number_0.title == ""
    assert number_0.description == ""
    assert number_0.allow_null is False
    assert number_0.minimum is None
    assert number_0.maximum is None
    assert number_0.exclusive_minimum is None
    assert number_0.exclusive_maximum is None
    assert number_0.multiple_of is None
    assert number_0.precision is None
    assert module_0.Number.errors == {
        "type": "Must be a number.",
        "null": "May not be null.",
        "integer": "Must be an integer.",
        "finite": "Must be finite.",
        "minimum": "Must be greater than or equal to {minimum}.",
        "exclusive_minimum": "Must be greater than {exclusive_minimum}.",
        "maximum": "Must be less than or equal to {maximum}.",
        "exclusive_maximum": "Must be less than {exclusive_maximum}.",
        "multiple_of": "Must be a multiple of {multiple_of}.",
    }
    int_0 = 478
    float_0 = module_0.Float(minimum=int_0, multiple_of=int_0)
    assert f"{type(float_0).__module__}.{type(float_0).__qualname__}" == "fields.Float"
    assert float_0.title == ""
    assert float_0.description == ""
    assert float_0.allow_null is False
    assert float_0.minimum == 478
    assert float_0.maximum is None
    assert float_0.exclusive_minimum is None
    assert float_0.exclusive_maximum is None
    assert float_0.multiple_of == 478
    assert float_0.precision is None
    boolean_0.validate(float_0, strict=int_0)


@pytest.mark.xfail(strict=True)
def test_case_81():
    array_0 = module_0.Array()
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    array_0.validate(array_0)


def test_case_82():
    int_0 = 613
    array_0 = module_0.Array(min_items=int_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items == 613
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }


def test_case_83():
    float_0 = 4737.81154
    number_0 = module_0.Number(maximum=float_0, exclusive_maximum=float_0)
    assert (
        f"{type(number_0).__module__}.{type(number_0).__qualname__}" == "fields.Number"
    )
    assert number_0.title == ""
    assert number_0.description == ""
    assert number_0.allow_null is False
    assert number_0.minimum is None
    assert number_0.maximum == pytest.approx(4737.81154, abs=0.01, rel=0.01)
    assert number_0.exclusive_minimum is None
    assert number_0.exclusive_maximum == pytest.approx(4737.81154, abs=0.01, rel=0.01)
    assert number_0.multiple_of is None
    assert number_0.precision is None
    assert module_0.Number.errors == {
        "type": "Must be a number.",
        "null": "May not be null.",
        "integer": "Must be an integer.",
        "finite": "Must be finite.",
        "minimum": "Must be greater than or equal to {minimum}.",
        "exclusive_minimum": "Must be greater than {exclusive_minimum}.",
        "maximum": "Must be less than or equal to {maximum}.",
        "exclusive_maximum": "Must be less than {exclusive_maximum}.",
        "multiple_of": "Must be a multiple of {multiple_of}.",
    }
    none_type_0 = None
    int_0 = -986
    validation_result_0 = number_0.validate_or_error(int_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == -986
    assert validation_result_0.error is None
    validation_result_1 = number_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value is None
    assert (
        f"{type(validation_result_1.error).__module__}.{type(validation_result_1.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_1.error) == 1


def test_case_84():
    dict_0 = {}
    time_0 = module_0.Time(**dict_0)
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None
    bool_0 = True
    object_0 = module_0.Object(min_properties=bool_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is True
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    with pytest.raises(AssertionError):
        module_0.Array(object_0, min_items=enum_dict_0)


def test_case_85():
    none_type_0 = None
    object_0 = module_0.Object(
        properties=none_type_0,
        pattern_properties=none_type_0,
        min_properties=none_type_0,
        max_properties=none_type_0,
    )
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_86():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(object_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_87():
    none_type_0 = None
    object_0 = module_0.Object(properties=none_type_0, property_names=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    module_0.Float(minimum=none_type_0, exclusive_maximum=object_0)


@pytest.mark.xfail(strict=True)
def test_case_88():
    text_0 = module_0.Text()
    assert f"{type(text_0).__module__}.{type(text_0).__qualname__}" == "fields.Text"
    assert text_0.title == ""
    assert text_0.description == ""
    assert text_0.allow_null is False
    assert text_0.allow_blank is False
    assert text_0.trim_whitespace is True
    assert text_0.max_length is None
    assert text_0.min_length is None
    assert text_0.format == "text"
    assert text_0.pattern is None
    assert text_0.pattern_regex is None
    validation_result_0 = text_0.validate_or_error(text_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    union_0 = text_0.__or__(text_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    var_0 = text_0.serialize(validation_result_0)
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert var_0.value is None
    assert (
        f"{type(var_0.error).__module__}.{type(var_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(var_0.error) == 1
    none_type_0 = None
    validation_result_1 = text_0.validate_or_error(union_0)
    assert validation_result_1.value is None
    assert (
        f"{type(validation_result_1.error).__module__}.{type(validation_result_1.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_1.error) == 1
    iterator_0 = validation_result_0.__iter__()
    union_1 = union_0.__or__(union_0)
    assert len(union_0.any_of) == 4
    assert f"{type(union_1).__module__}.{type(union_1).__qualname__}" == "fields.Union"
    assert union_1.title == ""
    assert union_1.description == ""
    assert union_1.allow_null is False
    assert (
        f"{type(union_1.any_of).__module__}.{type(union_1.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_1.any_of) == 4
    var_1 = module_1.getnode()
    bool_0 = validation_result_0.__bool__()
    assert bool_0 is False
    var_2 = text_0.serialize(var_0)
    assert var_2.value is None
    assert (
        f"{type(var_2.error).__module__}.{type(var_2.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(var_2.error) == 1
    module_0.Float(
        exclusive_minimum=var_0,
        exclusive_maximum=validation_result_0,
        precision=none_type_0,
    )


def test_case_89():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    union_0 = integer_0.__or__(integer_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    union_1 = union_0.__or__(integer_0)
    assert union_1.title == ""
    assert union_1.description == ""
    assert union_1.allow_null is False
    validation_result_0 = union_0.validate_or_error(union_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    iterator_0 = validation_result_0.__iter__()


def test_case_90():
    bool_0 = True
    object_0 = module_0.Object(min_properties=bool_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is True
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0, strict=object_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_91():
    bool_0 = False
    none_type_0 = None
    object_0 = module_0.Object(additional_properties=bool_0, max_properties=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is False
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    dict_0 = {}
    var_0 = object_0.validate(dict_0, strict=dict_0)
    boolean_0 = module_0.Boolean(default=none_type_0, allow_null=var_0)
    assert boolean_0.default is None
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert boolean_0.allow_null == {}
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    validation_result_0 = boolean_0.validate_or_error(bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is False
    assert validation_result_0.error is None


def test_case_92():
    str_0 = "U"
    bool_0 = True
    const_0 = module_0.Const(str_0)
    assert f"{type(const_0).__module__}.{type(const_0).__qualname__}" == "fields.Const"
    assert const_0.title == ""
    assert const_0.description == ""
    assert const_0.allow_null is False
    assert const_0.const == "U"
    assert module_0.Const.errors == {
        "only_null": "Must be null.",
        "const": "Must be the value '{const}'.",
    }
    validation_result_0 = const_0.validate_or_error(bool_0, strict=bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_93():
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    str_0 = ""
    validation_result_0 = date_time_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_94():
    none_type_0 = None
    array_0 = module_0.Array(none_type_0, exact_items=none_type_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    list_0 = [none_type_0]
    validation_result_0 = array_0.validate_or_error(list_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == [None]
    assert validation_result_0.error is None


def test_case_95():
    none_type_0 = None
    array_0 = module_0.Array(none_type_0, min_items=none_type_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    date_time_1 = array_0.serialize(none_type_0)
    validation_result_0 = date_time_0.validate_or_error(none_type_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_96():
    str_0 = "`"
    bool_0 = False
    string_0 = module_0.String(allow_blank=str_0, trim_whitespace=bool_0, pattern=str_0)
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank == "`"
    assert string_0.trim_whitespace is False
    assert string_0.max_length is None
    assert string_0.min_length is None
    assert string_0.format is None
    assert string_0.pattern == "`"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    var_0 = string_0.validate(str_0)
    assert var_0 == "`"
    var_1 = var_0.__le__(string_0)
    var_2 = var_0.__eq__(bool_0)
    var_2.validate(var_2)


def test_case_97():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "T!"
    string_0 = module_0.String(format=str_0)
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.allow_blank is False
    assert string_0.trim_whitespace is True
    assert string_0.max_length is None
    assert string_0.min_length is None
    assert string_0.format == "T!"
    assert string_0.pattern is None
    assert string_0.pattern_regex is None
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    var_0 = string_0.validate(str_0)
    assert var_0 == "T!"
    validation_result_0 = object_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_98():
    float_0 = 4726.0
    float_1 = 4040.22169
    float_2 = module_0.Float(maximum=float_0, exclusive_minimum=float_1)
    assert f"{type(float_2).__module__}.{type(float_2).__qualname__}" == "fields.Float"
    assert float_2.title == ""
    assert float_2.description == ""
    assert float_2.allow_null is False
    assert float_2.minimum is None
    assert float_2.maximum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_2.exclusive_minimum == pytest.approx(4040.22169, abs=0.01, rel=0.01)
    assert float_2.exclusive_maximum is None
    assert float_2.multiple_of is None
    assert float_2.precision is None
    validation_result_0 = float_2.validate_or_error(float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert validation_result_0.error is None


@pytest.mark.xfail(strict=True)
def test_case_99():
    float_0 = 2266.86
    float_1 = module_0.Float(
        minimum=float_0, maximum=float_0, exclusive_maximum=float_0
    )
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum == pytest.approx(2266.86, abs=0.01, rel=0.01)
    assert float_1.maximum == pytest.approx(2266.86, abs=0.01, rel=0.01)
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum == pytest.approx(2266.86, abs=0.01, rel=0.01)
    assert float_1.multiple_of is None
    assert float_1.precision is None
    var_0 = module_1.getnode()
    float_1.validate(var_0)


def test_case_100():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = "\tF$:koFw>/!']"
    dict_0 = {str_0: integer_0, str_0: integer_0, str_0: integer_0}
    object_0 = module_0.Object(properties=dict_0, additional_properties=integer_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert (
        f"{type(object_0.properties).__module__}.{type(object_0.properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_0.properties) == 1
    assert object_0.pattern_properties == {}
    assert (
        f"{type(object_0.additional_properties).__module__}.{type(object_0.additional_properties).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_101():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    object_0 = module_0.Object(properties=integer_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert (
        f"{type(object_0.additional_properties).__module__}.{type(object_0.additional_properties).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_102():
    float_0 = 4726.0
    float_1 = module_0.Float(minimum=float_0, precision=float_0)
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum == pytest.approx(4726.0, abs=0.01, rel=0.01)
    assert float_1.maximum is None
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of is None
    assert float_1.precision == pytest.approx(4726.0, abs=0.01, rel=0.01)
    union_0 = float_1.__or__(float_1)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    decimal_0 = module_4.Decimal()
    validation_result_0 = union_0.validate_or_error(decimal_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_103():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = "5]y 7`?P\x0bE>#"
    dict_0 = {
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
    }
    choice_0 = module_0.Choice(choices=dict_0)
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == [("5]y 7`?P\x0bE>#", "5]y 7`?P\x0bE>#")]
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    validation_result_0 = choice_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == "5]y 7`?P\x0bE>#"
    assert validation_result_0.error is None


def test_case_104():
    int_0 = 3161
    integer_0 = module_0.Integer(minimum=int_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == 3161
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    union_0 = integer_0.__or__(integer_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    validation_result_0 = union_0.validate_or_error(int_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == 3161
    assert validation_result_0.error is None


def test_case_105():
    time_0 = module_1.uuid4()
    str_0 = 'd`"]VUlo1r?6.@i\x0cN'
    dict_0 = {str_0: time_0}
    none_type_0 = None
    with pytest.raises(AssertionError):
        module_0.Object(properties=dict_0, property_names=none_type_0)


def test_case_106():
    var_0 = module_1.getnode()
    integer_0 = module_0.Integer(minimum=var_0, multiple_of=var_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == 32989410669706
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of == 32989410669706
    assert integer_0.precision is None
    object_0 = module_0.Object(max_properties=var_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties == 32989410669706
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = integer_0.validate_or_error(var_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == 32989410669706
    assert validation_result_0.error is None


def test_case_107():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "BBL "
    dict_0 = {
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
    }
    object_1 = module_0.Object(properties=dict_0, required=dict_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert (
        f"{type(object_1.properties).__module__}.{type(object_1.properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.properties) == 1
    assert object_1.pattern_properties == {}
    assert object_1.additional_properties is True
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert (
        f"{type(object_1.required).__module__}.{type(object_1.required).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.required) == 1
    validation_result_0 = object_1.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_108():
    none_type_0 = None
    decimal_0 = module_0.Decimal(
        minimum=none_type_0, maximum=none_type_0, exclusive_minimum=none_type_0
    )
    assert (
        f"{type(decimal_0).__module__}.{type(decimal_0).__qualname__}"
        == "fields.Decimal"
    )
    assert decimal_0.title == ""
    assert decimal_0.description == ""
    assert decimal_0.allow_null is False
    assert decimal_0.minimum is None
    assert decimal_0.maximum is None
    assert decimal_0.exclusive_minimum is None
    assert decimal_0.exclusive_maximum is None
    assert decimal_0.multiple_of is None
    assert decimal_0.precision is None
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    var_0 = object_0.get_default_value()
    object_1 = module_0.Object(pattern_properties=var_0, property_names=object_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert object_1.additional_properties is True
    assert (
        f"{type(object_1.property_names).__module__}.{type(object_1.property_names).__qualname__}"
        == "fields.Object"
    )
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert object_1.required == []
    var_1 = decimal_0.serialize(none_type_0)
    time_0 = module_0.Time()
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None
    validation_result_0 = object_1.validate_or_error(var_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    bool_0 = True
    validation_result_1 = time_0.validate_or_error(var_1, strict=bool_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value is None
    assert (
        f"{type(validation_result_1.error).__module__}.{type(validation_result_1.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_1.error) == 1


def test_case_109():
    none_type_0 = None
    str_0 = "="
    const_0 = module_0.Const(none_type_0)
    assert f"{type(const_0).__module__}.{type(const_0).__qualname__}" == "fields.Const"
    assert const_0.title == ""
    assert const_0.description == ""
    assert const_0.allow_null is False
    assert const_0.const is None
    assert module_0.Const.errors == {
        "only_null": "Must be null.",
        "const": "Must be the value '{const}'.",
    }
    bool_0 = True
    object_0 = module_0.Object(property_names=none_type_0, min_properties=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(object_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    boolean_0 = module_0.Boolean(default=bool_0, allow_null=object_0)
    assert boolean_0.default is True
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    validation_result_1 = boolean_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value is None
    assert (
        f"{type(validation_result_1.error).__module__}.{type(validation_result_1.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_1.error) == 1
    validation_result_2 = const_0.validate_or_error(object_0, strict=const_0)
    assert (
        f"{type(validation_result_2).__module__}.{type(validation_result_2).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_2.value is None
    assert (
        f"{type(validation_result_2.error).__module__}.{type(validation_result_2.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_2.error) == 1


def test_case_110():
    none_type_0 = None
    object_0 = module_0.Object(
        properties=none_type_0, min_properties=none_type_0, max_properties=none_type_0
    )
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    object_1 = module_2.purge()
    date_0 = module_0.Date()
    assert f"{type(date_0).__module__}.{type(date_0).__qualname__}" == "fields.Date"
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None
    str_0 = "itsu?zl,MaX++P:<bB'f"
    str_1 = "m+f"
    dict_0 = {str_0: object_1, str_1: object_1}
    with pytest.raises(AssertionError):
        module_0.Object(pattern_properties=dict_0)


def test_case_111():
    float_0 = 4715.531467332472
    float_1 = module_0.Float(multiple_of=float_0)
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum is None
    assert float_1.maximum is None
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of == pytest.approx(4715.531467332472, abs=0.01, rel=0.01)
    assert float_1.precision is None
    validation_result_0 = float_1.validate_or_error(float_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == pytest.approx(
        4715.531467332472, abs=0.01, rel=0.01
    )
    assert validation_result_0.error is None


def test_case_112():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    bool_0 = True
    object_1 = module_0.Object(additional_properties=object_0, max_properties=bool_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert (
        f"{type(object_1.additional_properties).__module__}.{type(object_1.additional_properties).__qualname__}"
        == "fields.Object"
    )
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is True
    assert object_1.required == []
    str_0 = "5ul\n4SIP01~&~_"
    field_0 = module_0.Field(
        title=str_0, description=str_0, default=object_1, allow_null=bool_0
    )
    assert (
        f"{type(field_0.default).__module__}.{type(field_0.default).__qualname__}"
        == "fields.Object"
    )
    union_0 = field_0.__or__(object_1)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is True
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    dict_0 = {bool_0: bool_0}
    validation_result_0 = object_1.validate_or_error(dict_0, strict=object_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_113():
    time_0 = module_0.Time()
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None
    none_type_0 = None
    str_0 = ""
    object_0 = module_0.Object(property_names=none_type_0, min_properties=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(object_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    bool_0 = validation_result_0.__bool__()
    assert bool_0 is False
    var_0 = object_0.get_default_value()
    boolean_0 = module_0.Boolean(default=var_0, allow_null=object_0)
    assert boolean_0.default is None
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    validation_result_1 = boolean_0.validate_or_error(str_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value is None
    assert validation_result_1.error is None
    validation_result_2 = time_0.validate_or_error(bool_0)
    assert (
        f"{type(validation_result_2).__module__}.{type(validation_result_2).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_2.value is None
    assert (
        f"{type(validation_result_2.error).__module__}.{type(validation_result_2.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_2.error) == 1
    validation_result_3 = time_0.validate_or_error(none_type_0, strict=bool_0)
    assert (
        f"{type(validation_result_3).__module__}.{type(validation_result_3).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_3.value is None
    assert (
        f"{type(validation_result_3.error).__module__}.{type(validation_result_3.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_3.error) == 1


def test_case_114():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "{eST"
    text_0 = module_0.Text()
    assert f"{type(text_0).__module__}.{type(text_0).__qualname__}" == "fields.Text"
    assert text_0.title == ""
    assert text_0.description == ""
    assert text_0.allow_null is False
    assert text_0.allow_blank is False
    assert text_0.trim_whitespace is True
    assert text_0.max_length is None
    assert text_0.min_length is None
    assert text_0.format == "text"
    assert text_0.pattern is None
    assert text_0.pattern_regex is None
    dict_0 = {str_0: object_0, str_0: object_0, str_0: object_0, str_0: object_0}
    object_1 = module_0.Object(pattern_properties=dict_0, property_names=object_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert (
        f"{type(object_1.pattern_properties).__module__}.{type(object_1.pattern_properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.pattern_properties) == 1
    assert object_1.additional_properties is True
    assert (
        f"{type(object_1.property_names).__module__}.{type(object_1.property_names).__qualname__}"
        == "fields.Object"
    )
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert object_1.required == []
    none_type_0 = None
    array_0 = module_0.Array(object_1, min_items=none_type_0, exact_items=none_type_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert (
        f"{type(array_0.items).__module__}.{type(array_0.items).__qualname__}"
        == "fields.Object"
    )
    assert array_0.additional_items is False
    assert array_0.min_items is None
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    validation_result_0 = array_0.serialize(dict_0)


def test_case_115():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_116():
    bool_0 = False
    object_0 = module_0.Object(min_properties=bool_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is False
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0, strict=bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_117():
    none_type_0 = None
    object_0 = module_0.Object(
        properties=none_type_0,
        additional_properties=none_type_0,
        property_names=none_type_0,
    )
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is None
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_118():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    bool_0 = True
    object_1 = module_0.Object(additional_properties=object_0, max_properties=bool_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert (
        f"{type(object_1.additional_properties).__module__}.{type(object_1.additional_properties).__qualname__}"
        == "fields.Object"
    )
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is True
    assert object_1.required == []
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_1.validate_or_error(enum_dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_119():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    object_0 = module_0.Object(additional_properties=integer_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert (
        f"{type(object_0.additional_properties).__module__}.{type(object_0.additional_properties).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_120():
    bool_0 = True
    date_0 = module_0.Date()
    assert f"{type(date_0).__module__}.{type(date_0).__qualname__}" == "fields.Date"
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None
    none_type_0 = None
    string_0 = module_0.String(allow_blank=bool_0, pattern=none_type_0)
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    validation_result_0 = string_0.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == ""
    assert validation_result_0.error is None


def test_case_121():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    dict_0 = {object_0: object_0}
    validation_result_0 = object_0.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_122():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "x'"
    dict_0 = {str_0: object_0}
    validation_result_0 = object_0.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert (
        f"{type(validation_result_0.value).__module__}.{type(validation_result_0.value).__qualname__}"
        == "builtins.dict"
    )
    assert len(validation_result_0.value) == 1
    assert validation_result_0.error is None


@pytest.mark.xfail(strict=True)
def test_case_123():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    bool_0 = False
    object_1 = module_0.Object(additional_properties=object_0, max_properties=bool_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert (
        f"{type(object_1.additional_properties).__module__}.{type(object_1.additional_properties).__qualname__}"
        == "fields.Object"
    )
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is False
    assert object_1.required == []
    dict_0 = {bool_0: bool_0}
    validation_result_0 = object_1.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    var_0 = module_1.getnode()
    var_1 = object_0.get_default_value()
    var_1.validate(validation_result_0, strict=var_0)


def test_case_124():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    var_0 = object_0.serialize(object_0)
    assert var_0.title == ""
    assert var_0.description == ""
    assert var_0.allow_null is False
    assert var_0.properties == {}
    assert var_0.pattern_properties == {}
    assert var_0.additional_properties is True
    assert var_0.property_names is None
    assert var_0.min_properties is None
    assert var_0.max_properties is None
    assert var_0.required == []
    bool_0 = True
    object_1 = module_0.Object(additional_properties=object_0, max_properties=bool_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert (
        f"{type(object_1.additional_properties).__module__}.{type(object_1.additional_properties).__qualname__}"
        == "fields.Object"
    )
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is True
    assert object_1.required == []
    dict_0 = {bool_0: bool_0}
    with pytest.raises(AssertionError):
        module_0.Object(
            properties=object_1, pattern_properties=dict_0, required=object_0
        )


@pytest.mark.xfail(strict=True)
def test_case_125():
    str_0 = ""
    int_0 = 3161
    integer_0 = module_0.Integer(minimum=int_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == 3161
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    number_0 = module_0.Number(precision=str_0)
    assert number_0.title == ""
    assert number_0.description == ""
    assert number_0.allow_null is False
    assert module_0.Number.errors == {
        "type": "Must be a number.",
        "null": "May not be null.",
        "integer": "Must be an integer.",
        "finite": "Must be finite.",
        "minimum": "Must be greater than or equal to {minimum}.",
        "exclusive_minimum": "Must be greater than {exclusive_minimum}.",
        "maximum": "Must be less than or equal to {maximum}.",
        "exclusive_maximum": "Must be less than {exclusive_maximum}.",
        "multiple_of": "Must be a multiple of {multiple_of}.",
    }
    none_type_0 = None
    object_0 = module_0.Object(required=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    number_0.validate(int_0)


def test_case_126():
    bool_0 = False
    none_type_0 = None
    object_0 = module_0.Object(additional_properties=bool_0, max_properties=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is False
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    dict_0 = {bool_0: bool_0}
    validation_result_0 = object_0.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_127():
    var_0 = module_1.getnode()
    integer_0 = module_0.Integer(minimum=var_0, multiple_of=var_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == 32989410669706
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of == 32989410669706
    assert integer_0.precision is None
    validation_result_0 = integer_0.validate_or_error(var_0, strict=var_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == 32989410669706
    assert validation_result_0.error is None


def test_case_128():
    none_type_0 = None
    dict_0 = {none_type_0: none_type_0, none_type_0: none_type_0}
    with pytest.raises(AssertionError):
        module_0.Object(min_properties=none_type_0, required=dict_0)


@pytest.mark.xfail(strict=True)
def test_case_129():
    time_0 = module_0.Time()
    assert f"{type(time_0).__module__}.{type(time_0).__qualname__}" == "fields.Time"
    assert time_0.title == ""
    assert time_0.description == ""
    assert time_0.allow_null is False
    assert time_0.allow_blank is False
    assert time_0.trim_whitespace is True
    assert time_0.max_length is None
    assert time_0.min_length is None
    assert time_0.format == "time"
    assert time_0.pattern is None
    assert time_0.pattern_regex is None
    none_type_0 = None
    object_0 = module_0.Object(property_names=none_type_0, min_properties=none_type_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    validation_result_0 = object_0.validate_or_error(object_0, strict=none_type_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    bool_0 = validation_result_0.__bool__()
    assert bool_0 is False
    var_0 = object_0.get_default_value()
    boolean_0 = module_0.Boolean(default=var_0, allow_null=object_0)
    assert boolean_0.default is None
    assert boolean_0.title == ""
    assert boolean_0.description == ""
    assert module_0.Boolean.errors == {
        "type": "Must be a boolean.",
        "null": "May not be null.",
    }
    assert module_0.Boolean.coerce_values == {
        "true": True,
        "false": False,
        "on": True,
        "off": False,
        "1": True,
        "0": False,
        "": False,
        1: True,
        0: False,
    }
    assert module_0.Boolean.coerce_null_values == {"", "null", "none"}
    union_0 = time_0.__or__(time_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    union_1 = boolean_0.__or__(boolean_0)
    assert union_1.title == ""
    assert union_1.description == ""
    assert union_1.allow_null is True
    validation_result_1 = union_1.validate_or_error(none_type_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value is None
    assert validation_result_1.error is None
    module_0.Object(
        properties=object_0,
        additional_properties=union_1,
        min_properties=union_1,
        max_properties=none_type_0,
        **none_type_0,
    )


def test_case_130():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "/$5"
    dict_0 = {
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
    }
    object_1 = module_0.Object(pattern_properties=dict_0, property_names=object_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert (
        f"{type(object_1.pattern_properties).__module__}.{type(object_1.pattern_properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.pattern_properties) == 1
    assert object_1.additional_properties is True
    assert (
        f"{type(object_1.property_names).__module__}.{type(object_1.property_names).__qualname__}"
        == "fields.Object"
    )
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert object_1.required == []
    validation_result_0 = object_1.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_131():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "{epXT7"
    dict_0 = {str_0: object_0, str_0: object_0, str_0: object_0, str_0: object_0}
    object_1 = module_0.Object(pattern_properties=dict_0, property_names=object_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert (
        f"{type(object_1.pattern_properties).__module__}.{type(object_1.pattern_properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.pattern_properties) == 1
    assert object_1.additional_properties is True
    assert (
        f"{type(object_1.property_names).__module__}.{type(object_1.property_names).__qualname__}"
        == "fields.Object"
    )
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert object_1.required == []
    validation_result_0 = object_1.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_132():
    bool_0 = True
    str_0 = "-c"
    string_0 = module_0.String(
        allow_blank=bool_0,
        trim_whitespace=bool_0,
        max_length=bool_0,
        pattern=str_0,
        format=str_0,
    )
    assert (
        f"{type(string_0).__module__}.{type(string_0).__qualname__}" == "fields.String"
    )
    assert string_0.title == ""
    assert string_0.description == ""
    assert string_0.allow_null is False
    assert string_0.default == ""
    assert string_0.allow_blank is True
    assert string_0.trim_whitespace is True
    assert string_0.max_length is True
    assert string_0.min_length is None
    assert string_0.format == "-c"
    assert string_0.pattern == "-c"
    assert (
        f"{type(string_0.pattern_regex).__module__}.{type(string_0.pattern_regex).__qualname__}"
        == "re.Pattern"
    )
    assert module_0.String.errors == {
        "type": "Must be a string.",
        "null": "May not be null.",
        "blank": "Must not be blank.",
        "max_length": "Must have no more than {max_length} characters.",
        "min_length": "Must have at least {min_length} characters.",
        "pattern": "Must match the pattern /{pattern}/.",
        "format": "Must be a valid {format}.",
    }
    none_type_0 = None
    decimal_0 = module_0.Decimal(precision=none_type_0, multiple_of=none_type_0)
    assert (
        f"{type(decimal_0).__module__}.{type(decimal_0).__qualname__}"
        == "fields.Decimal"
    )
    assert decimal_0.title == ""
    assert decimal_0.description == ""
    assert decimal_0.allow_null is False
    assert decimal_0.minimum is None
    assert decimal_0.maximum is None
    assert decimal_0.exclusive_minimum is None
    assert decimal_0.exclusive_maximum is None
    assert decimal_0.multiple_of is None
    assert decimal_0.precision is None
    validation_result_0 = string_0.validate_or_error(none_type_0, strict=bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_133():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    dict_0 = {object_0: object_0}
    union_0 = module_0.Union(dict_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.dict"
    )
    assert len(union_0.any_of) == 1
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    bool_0 = True
    validation_result_0 = union_0.validate_or_error(dict_0, strict=bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_134():
    float_0 = 4714.705609969592
    date_0 = module_0.Date()
    assert f"{type(date_0).__module__}.{type(date_0).__qualname__}" == "fields.Date"
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None
    float_1 = module_0.Float(multiple_of=float_0)
    assert f"{type(float_1).__module__}.{type(float_1).__qualname__}" == "fields.Float"
    assert float_1.title == ""
    assert float_1.description == ""
    assert float_1.allow_null is False
    assert float_1.minimum is None
    assert float_1.maximum is None
    assert float_1.exclusive_minimum is None
    assert float_1.exclusive_maximum is None
    assert float_1.multiple_of == pytest.approx(4714.705609969592, abs=0.01, rel=0.01)
    assert float_1.precision is None
    int_0 = -619
    validation_result_0 = float_1.validate_or_error(int_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_135():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "9d{epXT7"
    dict_0 = {str_0: object_0, str_0: object_0, str_0: object_0, str_0: object_0}
    int_0 = 1360
    object_1 = module_0.Object(min_properties=int_0, max_properties=int_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert object_1.additional_properties is True
    assert object_1.property_names is None
    assert object_1.min_properties == 1360
    assert object_1.max_properties == 1360
    assert object_1.required == []
    bool_0 = False
    validation_result_0 = object_1.validate_or_error(dict_0, strict=bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_136():
    bool_0 = True
    array_0 = module_0.Array(max_items=bool_0, exact_items=bool_0, unique_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is True
    assert array_0.max_items is True
    assert array_0.unique_items is True
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    list_0 = [array_0]
    array_0.validate_or_error(list_0)


def test_case_137():
    bool_0 = False
    array_0 = module_0.Array(max_items=bool_0, exact_items=bool_0, unique_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is False
    assert array_0.max_items is False
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    list_0 = [array_0]
    validation_result_0 = array_0.validate_or_error(list_0, strict=array_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_138():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = ""
    dict_0 = {str_0: integer_0, str_0: integer_0, str_0: integer_0}
    object_0 = module_0.Object(properties=dict_0, additional_properties=integer_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert (
        f"{type(object_0.properties).__module__}.{type(object_0.properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_0.properties) == 1
    assert object_0.pattern_properties == {}
    assert (
        f"{type(object_0.additional_properties).__module__}.{type(object_0.additional_properties).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_0.validate_or_error(enum_dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value == {}
    assert validation_result_0.error is None


def test_case_139():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "{eXT"
    dict_0 = {str_0: object_0, str_0: object_0, str_0: object_0, str_0: object_0}
    object_1 = module_0.Object(additional_properties=object_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert object_1.properties == {}
    assert object_1.pattern_properties == {}
    assert (
        f"{type(object_1.additional_properties).__module__}.{type(object_1.additional_properties).__qualname__}"
        == "fields.Object"
    )
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert object_1.required == []
    validation_result_0 = object_1.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


@pytest.mark.xfail(strict=True)
def test_case_140():
    regex_flag_0 = module_2.RegexFlag.VERBOSE
    date_0 = module_0.Date()
    assert f"{type(date_0).__module__}.{type(date_0).__qualname__}" == "fields.Date"
    assert date_0.title == ""
    assert date_0.description == ""
    assert date_0.allow_null is False
    assert date_0.allow_blank is False
    assert date_0.trim_whitespace is True
    assert date_0.max_length is None
    assert date_0.min_length is None
    assert date_0.format == "date"
    assert date_0.pattern is None
    assert date_0.pattern_regex is None
    integer_0 = module_0.Integer(minimum=regex_flag_0, multiple_of=regex_flag_0)
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum == module_2.RegexFlag.VERBOSE
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of == module_2.RegexFlag.VERBOSE
    assert integer_0.precision is None
    enum_dict_0 = module_3._EnumDict()
    var_0 = module_1.uuid1()
    integer_0.validate(var_0)


def test_case_141():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    union_0 = integer_0.__or__(integer_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    none_type_0 = None
    list_0 = []
    object_0 = module_0.Object(
        property_names=integer_0,
        min_properties=none_type_0,
        max_properties=none_type_0,
        required=list_0,
    )
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert (
        f"{type(object_0.property_names).__module__}.{type(object_0.property_names).__qualname__}"
        == "fields.Integer"
    )
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    bool_0 = False
    validation_result_0 = integer_0.validate_or_error(list_0, strict=bool_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_142():
    list_0 = []
    bool_0 = True
    array_0 = module_0.Array(list_0, unique_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items == []
    assert array_0.additional_items is False
    assert array_0.min_items == 0
    assert array_0.max_items == 0
    assert array_0.unique_items is True
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }


def test_case_143():
    object_0 = module_0.Object()
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    str_0 = "BBL "
    dict_0 = {
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
        str_0: object_0,
    }
    object_1 = module_0.Object(properties=dict_0, required=dict_0)
    assert (
        f"{type(object_1).__module__}.{type(object_1).__qualname__}" == "fields.Object"
    )
    assert object_1.title == ""
    assert object_1.description == ""
    assert object_1.allow_null is False
    assert (
        f"{type(object_1.properties).__module__}.{type(object_1.properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.properties) == 1
    assert object_1.pattern_properties == {}
    assert object_1.additional_properties is True
    assert object_1.property_names is None
    assert object_1.min_properties is None
    assert object_1.max_properties is None
    assert (
        f"{type(object_1.required).__module__}.{type(object_1.required).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_1.required) == 1
    enum_dict_0 = module_3._EnumDict()
    validation_result_0 = object_1.validate_or_error(enum_dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_144():
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = "xb"
    dict_0 = {
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
    }
    choice_0 = module_0.Choice()
    assert (
        f"{type(choice_0).__module__}.{type(choice_0).__qualname__}" == "fields.Choice"
    )
    assert choice_0.title == ""
    assert choice_0.description == ""
    assert choice_0.allow_null is False
    assert choice_0.choices == []
    assert module_0.Choice.errors == {
        "null": "May not be null.",
        "required": "This field is required.",
        "choice": "Not a valid choice.",
    }
    object_0 = module_0.Object(properties=dict_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert (
        f"{type(object_0.properties).__module__}.{type(object_0.properties).__qualname__}"
        == "builtins.dict"
    )
    assert len(object_0.properties) == 1
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is True
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    union_0 = object_0.__or__(integer_0)
    assert f"{type(union_0).__module__}.{type(union_0).__qualname__}" == "fields.Union"
    assert union_0.title == ""
    assert union_0.description == ""
    assert union_0.allow_null is False
    assert (
        f"{type(union_0.any_of).__module__}.{type(union_0.any_of).__qualname__}"
        == "builtins.list"
    )
    assert len(union_0.any_of) == 2
    assert module_0.Union.errors == {
        "null": "May not be null.",
        "union": "Did not match any valid type.",
    }
    bool_0 = integer_0.has_default()
    assert bool_0 is False
    var_0 = choice_0.get_default_value()
    validation_result_0 = union_0.validate_or_error(var_0, strict=str_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
    date_time_0 = module_0.DateTime()
    assert (
        f"{type(date_time_0).__module__}.{type(date_time_0).__qualname__}"
        == "fields.DateTime"
    )
    assert date_time_0.title == ""
    assert date_time_0.description == ""
    assert date_time_0.allow_null is False
    assert date_time_0.allow_blank is False
    assert date_time_0.trim_whitespace is True
    assert date_time_0.max_length is None
    assert date_time_0.min_length is None
    assert date_time_0.format == "datetime"
    assert date_time_0.pattern is None
    assert date_time_0.pattern_regex is None
    validation_result_1 = union_0.validate_or_error(dict_0, strict=dict_0)
    assert (
        f"{type(validation_result_1).__module__}.{type(validation_result_1).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_1.value is None
    assert (
        f"{type(validation_result_1.error).__module__}.{type(validation_result_1.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_1.error) == 1


def test_case_145():
    bool_0 = True
    array_0 = module_0.Array(min_items=bool_0, unique_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is True
    assert array_0.max_items is None
    assert array_0.unique_items is True
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    list_0 = []
    validation_result_0 = array_0.validate_or_error(list_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1


def test_case_146():
    bool_0 = False
    array_0 = module_0.Array(additional_items=bool_0, min_items=bool_0)
    assert f"{type(array_0).__module__}.{type(array_0).__qualname__}" == "fields.Array"
    assert array_0.title == ""
    assert array_0.description == ""
    assert array_0.allow_null is False
    assert array_0.items is None
    assert array_0.additional_items is False
    assert array_0.min_items is False
    assert array_0.max_items is None
    assert array_0.unique_items is False
    assert module_0.Array.errors == {
        "type": "Must be an array.",
        "null": "May not be null.",
        "empty": "Must not be empty.",
        "exact_items": "Must have {min_items} items.",
        "min_items": "Must have at least {min_items} items.",
        "max_items": "Must have no more than {max_items} items.",
        "additional_items": "May not contain additional items.",
        "unique_items": "Items must be unique.",
    }
    var_0 = array_0.get_default_value()
    object_0 = module_0.Object(properties=var_0, additional_properties=bool_0)
    assert (
        f"{type(object_0).__module__}.{type(object_0).__qualname__}" == "fields.Object"
    )
    assert object_0.title == ""
    assert object_0.description == ""
    assert object_0.allow_null is False
    assert object_0.properties == {}
    assert object_0.pattern_properties == {}
    assert object_0.additional_properties is False
    assert object_0.property_names is None
    assert object_0.min_properties is None
    assert object_0.max_properties is None
    assert object_0.required == []
    assert module_0.Object.errors == {
        "type": "Must be an object.",
        "null": "May not be null.",
        "invalid_key": "All object keys must be strings.",
        "required": "This field is required.",
        "invalid_property": "Invalid property name.",
        "empty": "Must not be empty.",
        "max_properties": "Must have no more than {max_properties} properties.",
        "min_properties": "Must have at least {min_properties} properties.",
    }
    integer_0 = module_0.Integer()
    assert (
        f"{type(integer_0).__module__}.{type(integer_0).__qualname__}"
        == "fields.Integer"
    )
    assert integer_0.title == ""
    assert integer_0.description == ""
    assert integer_0.allow_null is False
    assert integer_0.minimum is None
    assert integer_0.maximum is None
    assert integer_0.exclusive_minimum is None
    assert integer_0.exclusive_maximum is None
    assert integer_0.multiple_of is None
    assert integer_0.precision is None
    str_0 = ""
    dict_0 = {
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
        str_0: integer_0,
    }
    validation_result_0 = object_0.validate_or_error(dict_0)
    assert (
        f"{type(validation_result_0).__module__}.{type(validation_result_0).__qualname__}"
        == "base.ValidationResult"
    )
    assert validation_result_0.value is None
    assert (
        f"{type(validation_result_0.error).__module__}.{type(validation_result_0.error).__qualname__}"
        == "base.ValidationError"
    )
    assert len(validation_result_0.error) == 1
